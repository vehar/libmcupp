# libmcupp
Библиотека вспомогательного кода на С++ для использования на микроконтроллерах, в первую очередь - ARM Cortex-M. Здесь нет HAL или подобных железо-зависимых вещей, только утилиты.

Над созданием работают:
* [emdc](https://github.com/emdc/)
* [Catethysis](https://github.com/Catethysis/)

Содержимое библиотеки:
- Graphics: функции для работы с графикой, обобщенные. 
 - ColorProfiles: цветовые профили. Представлены RGB (integer & float), HSV (integer & float) и COLORREF. Целочисленные варианты представлены для более быстрых преобразований, float - для более точных. 
- Utils: общие утилиты.
 - Sugar: синтаксический сахар и определения ключевых слов из C++11 для компиляторов, которые поддерживают только C++03, а так же общие заготовочные файлы, например stdint.h.
 - Debug: набор макросов для отладки. Сделано так, чтобы при отключении символа __DEBUG__ данные функции не попадали в конечный бинарный код.
 - Buffer: простая олбертка над массивом байт. Содержит внутренний итератор, а так же флаг блокировки. Версия без исключений, возможны выходы за пределы массива!
 - Callback: модуль для унифицированного вызова как методов, так и функций с одинаковыми входными и выходными параметрами. 
 
## Примеры
### Utils::Debug
В данном варианте присутствуют две функции: DEBUG_PRINT() и DEBUG_CHECK(). 
DEBUG_PRINT(...) - обычный printf, но по желанию можно заменить на что угодно, лишь бы на входе было __VA_ARGS__.
DEBUG_CHECK(condition, errfcn, ...) - создан для проверки входных параметров. Первым параметром идет обычное условие, которое должно возвращать true или false. Второй параметр - функция, которую нужно выполнить в результате неудачи. Специально сделано так, чтобы можно было вставить 1-2 оператора по необходимости. __VA_ARGS__ в конце нужен для отладочного вывода. Если отключить DEBUG_PRINT(), то выполнится только errfcn. Пример использования:
```C++
float inverse(float arg) {
  DEBUG_CHECK(arg == 0, return 0, "Argument == 0! 1/arg = INF\n");
  return (1 / arg);
}
```
В данном варианте если аргумент неверный, то можно вернуть сразу код ошибки или нечто подобное. Если возвращаемого значения нет - просто выйти, либо задать выходное значение через параметр-указатель. Другой вариант, когда из функции вызывается исключение:
```C++
class InverseException {};

float inverse(float arg) {
  DEBUG_CHECK(arg == 0, throw InverseException(), "Argument == 0! 1/arg = INF\n");
  return (1 / arg);
}
```
Вызов данной функции тогда можно обернуть в try-catch блок, а после отладки и получения стабильного состояния исключения кидаться уже не будут:
```C++
DEBUG_TRY_BEGIN()
	printf("Value: %d\n", inverse(10));
	printf("Value: %d\n", inverse(0));
DEBUG_TRY_END() 
DEBUG_CATCH(printf("Error!"));
```
Таким образом, в режиме отладки можно включить работу с исключениями и RTTI, а в релизной версии отключить, что высвободит несколько кб памяти (например, для IAR ARM v7.5 ~5кб).

### Utils::Callback
В данном модуле представлен шаблон-интерфейс колбэка, а так же классы для функций-колбэков и методов-колбэков. Использовать их можно следующим образом:
```C++
void fcn() {
	printf("%s\n", __FUNCTION__);
}

class Some {
public:
	void method() {
		printf("%s\n", __FUNCTION__);
	}
};

int main() {
	Some obj;

	Utils::FcnCallback<> fcnCallback(fcn);
	Utils::ObjCallback<Some> objCallback(&obj, &Some::method);

	Utils::ICallback<>& cb = fcnCallback;
	//Utils::ICallback<>& cb = objCallback;
	cb();
	return 0;
}
```

Если раскомментирована первая строка (`Utils::ICallback<>& cb = fcnCallback;`), то вывод будет следующий: `fcn`. Если раскомментирована вторая строка (`Utils::ICallback<>& cb = objCallback;`), то вывод уже будет такой: `Some::method`. Естественно, можно кроме ссылки использовать и указатель, тогда вызов будет происходить следующим образом:
```C++
Utils::ICallback<>* cb = &objCallback;
(*cb)();
// либо
cb->call();
```
В интерфейсе есть метод `isValid()`, который возвращает bool и показывает, что колбэк проинициализирован и готов к вызову. В объектах так же присутствует метод `set()`, который позволяет задать другую функцию для вызова (либо сбросить оную, передав `nullptr`).
